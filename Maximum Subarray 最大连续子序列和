思路：
1、状态转移方程：dp[i]=max(dp[i-1]+nums[i], nums[i])
   其中dp[i]的意思是以第i个数结尾的最长子序列和的结果
2、初始状态：dp[0]=nums[0]

https://leetcode.com/problems/maximum-subarray/

class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        if(nums.size()==0) return 0;
        int maxn=nums[0];
        vector<int>dp(nums.size(),nums[0]);
        for(int i=1;i<nums.size();++i){
            dp[i]=max(dp[i-1]+nums[i],nums[i]);
            maxn=max(maxn,dp[i]);
        }
        return maxn;
    }
};
